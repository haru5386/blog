---
title: 深入解析 Unicode：電腦如何處理文字與符號
date: 2025-04-09
category: basics
abstract: Unicode 是現代電腦理解全球文字的基礎，這篇文章深入探討 Unicode 的運作方式，並且比較 UTF-8 和 UTF-16 兩大編碼方式，讓你更了解如何將文字轉換成電腦可讀的數字。
tags: [Unicode, encoding, UTF-8, UTF-16, character-encoding, computer-basics]
---

既然我們上一章節已經講完二進制，那我們現在來聊聊 Unicode 吧！我們已經了解電腦只能看得懂 1 和 0，但人類有這麼多的文字，又要怎麼讓電腦看得懂呢？所以需要有字元編碼標準來幫助電腦理解。

#### ASCII

但最早推出字元編碼標準的是 ASCII（American Standard Code for Information Interchange，美國資訊交換標準碼, 1963），它只包含了英文字母、數字、標點符號要用哪個數字來代表。

- **特點：**

  使用 7 個位元（bits） 編碼 → 可以表示 **128 個字元**（從 0 到 127）。  
  每個字元對應一個數字（碼點），然後這個數字會被儲存成二進位格式。

  | 字元 | ASCII 碼點（十進位） | 二進位表示 |
  | :--: | :------------------: | :--------: |
  |  A   |          65          |  01000001  |
  |  a   |          97          |  01100001  |
  |  0   |          48          |  00110000  |
  | 空格 |          32          |  00100000  |
  |  !   |          33          |  00100001  |

#### Unicode

Unicode 的出現，是為了解決 ASCII 的限制：**全世界這麼多語言、字元和表情符號，128 個不夠用啊！**
所以 Unicode 為所有語言的每一個字元，都賦予一個全球唯一的碼點（code point），從 U+0000 到 U+10FFFF，超過百萬種可能。

有些讀者可能會問，為什麼這樣就有百萬種可能？

我們上一篇有提過十六進位，把碼點的 U+ 去掉之後，是不是覺得很眼熟。Unicode 就是用了十六進位法，而 U+ 就是 Unicode 的前綴。

最後一個碼點是：10FFFF = 1 × 16^5 + 0 × 16^4 + F×16^3 + F×16^2 + F×16^1 + F×16^0 = 1,114,111

把起點加上去，整個 Unicode 的區段就有 **1,114,112 個碼點**。但並非每個都有對應到一個字符喔，有些保留區段與禁用區段。

##### 為什麼不用十進位呢？

雖然每個 Unicode 碼點對應的實際是個十進位整數（像 U+0041 = 65），但用 16 進位，
是因為更方便配合電腦的二進制系統（4 位元 = 1 位十六進位），我們[上一篇](/blog/basics/2)也有講過這個算法。
這樣顯示起來也更簡潔、好閱讀，一眼就能看出字元位於哪個區段，我們可以用下表對照：

|        區段名稱        | 範圍（十六進位）  |                說明                |
| :--------------------: | :---------------: | :--------------------------------: |
|      Basic Latin       |  U+0000 - U+007F  | 英文、數字、控制符號（等於 ASCII） |
|   Latin-1 Supplement   |  U+0080 - U+00FF  |       帶變音符的西歐語言字母       |
| CJK Unified Ideographs |  U+4E00 - U+9FFF  |     中文、日文、韓文的常用漢字     |
|       Emoticons        | U+1F600 - U+1F64F |          表情符號 😄🤣😍           |

Unicode 最初被設計成最大是 21 bits，最小是 1 bit，但電腦記憶體的儲存空間與檔案格式、通訊協定幾乎都以字節 (byte) 為基本單位，相當於 8 個字元 (bits)，如果直接將 Unicode 轉換成二進位儲存，這樣會斷裂在位元組中間。

舉例來說：假設你每盒只能放 8 顆糖（= 1 byte），但你手上有 21 顆糖（= 21 bits），你不能就這樣塞進去，會有盒子放不下、又不能切半放。
因此，這些碼點需要「具體用幾個位元儲存？」的規則，這就是 UTF-8、UTF-16、UTF-32 這些編碼方式出現的原因。

#### 編碼規則的用途

我們需要將 Unicode 碼點修改成可以儲存的格式，但 Unicode 範圍超過 1,100,000 個字符。這個範圍非常大，超過了單個字節（8 位）可以表示的數字範圍（最大只能表示 256 個不同的值，即 0x00 到 0xFF）。因此，Unicode 碼點必須被映射到多個字節上來表示。
一個字節只能表示 0 到 255 之間的數字。而如果字符的 Unicode 碼點大於 255，就無法用單一字節來表示，必須用多個字節來表示這些較大的碼點。

**UTF-8 和 UTF-16 是兩種常用的 Unicode 編碼方式**

UTF-8 和 UTF-16 有各自使用的情境，以下是兩者比較方式

- UTF-8 與 UTF-16 的主要區別

  |   特性   |           UTF-8            |             UTF-16             |
  | :------: | :------------------------: | :----------------------------: |
  | 編碼長度 |  可變長度（1 到 4 字節）   |    可變長度（2 或 4 字節）     |
  | 字符範圍 |     U+0000 到 U+10FFFF     |       U+0000 到 U+10FFFF       |
  |   優勢   |  節省空間，與 ASCII 兼容   | 多語言支持較好，簡單的字節處理 |
  |   缺點   |    解析多字節字符較麻煩    |  處理 ASCII 字符時會浪費空間   |
  | 適用場景 | 網頁、網絡傳輸、兼容 ASCII |  內部存儲、大多數操作系統支持  |

- **UTF-8**：**是目前網絡上最廣泛使用的編碼方式**，尤其是 HTML、JSON 等格式的應用，因為傳 HTML 與 JSON 大多傳的是西方文字。
- **UTF-16**：但如果應用涉及大量東亞語言（如中文、日文、韓文），UTF-16 是一個比較好的選擇。這些語言的字符大多使用 2 字節表示，處理多語言來說效能更好。

---

接下來我們用 Javascript 實際操作 Unicode 轉換成 UTF-8 和 UTF-16 的語法。

##### 1. Unicode 轉 UTF-8

使用 `TextEncoder` 來將 Unicode 字符轉換為 UTF-8：

```c
// UTF-8 編碼
function toUtf8(inputChar) {
  const encoder = new TextEncoder();
  const encoded = encoder.encode(inputChar);
  const hex = Array.from(encoded).map(byte => byte.toString(16).padStart(2, '0')).join(' ');
  return hex;
}

const char = '🐶';  // 這是 Unicode 字符
console.log("UTF-8 編碼:", toUtf8(char));
```

##### 2. Unicode 轉 UTF-16

使用 `charCodeAt()` 可以取得每個字符對應的 UTF-16 編碼（即碼點）：

```c
// UTF-16 編碼
function toUtf16(inputChar) {
  const codes = [];
  for (let i = 0; i < inputChar.length; i++) {
    codes.push(inputChar.charCodeAt(i).toString(16).padStart(4, '0'));  // 將每個碼點轉換為 16 進位字串
  }
  return codes.join(' ');
}

const char = '🐶';  // 這是 Unicode 字符
console.log("UTF-16 編碼:", toUtf16(char));
```

---

下面可以在 input 輸入字符，看看 Unicode、UTF-8、UTF-16 轉換：

<TransferUtf8 />

---

### 再來介紹一個很常看到編碼方式：**Base64**

Base64 是一種編碼方式，通常用來將二進位資料（如圖片、文件、音訊等）轉換成只包含字母、數字和少數特殊符號的 ASCII 字符串。

這樣可以讓原本的二進位資料（無法直接在文字系統中顯示）以可顯示的字符形式進行儲存或傳輸，常見於 URL、電子郵件附件、網頁中嵌入圖片等場景。

Base64 編碼的過程就是將每 3 個 bytes（24 位元）轉換為 4 個 Base64 字符（每個字符代表 6 位元）。這樣可以讓任何二進位資料在只支援文本的環境中進行有效傳輸。

Base64 使用的 64 個字符集是：

```
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
```

#### Base64 編碼過程與進位制的關係：

1. 原始資料（Binary）：

原始資料通常以二進制（Binary）格式存在，例如檔案或文本的字節數據。每個字節（Byte）有 8 個二進位位元（bit），即 0 或 1。

2. 將原始資料轉換為 6 位的二進位表示：

Base64 編碼將原始的 8 位字節分成 6 位一組來處理。具體來說，Base64 會將 3 個 8 位字節（即 3 個字節）組合成一個 24 位的長度。

接著，這 24 位的二進位數據會被分成 4 組，每組 6 位：

24 位 ÷ 4 組 = 每組 6 位。

這樣做是因為 Base64 的每個編碼字符代表 6 位二進位數據，而不是 8 位。

3. 轉換為 Base64 字符：

每 6 位二進位數據都會對應一個 Base64 字符。Base64 字符集包含 64 個字符（通常是大寫字母、字母、數字、"+" 和 "/"），這些字符對應於 6 位的二進位數據。

例如，Base64 編碼中的字符 'A' 代表二進位 000000，字符 'B' 代表二進位 000001，以此類推。

4. 處理不足 6 位的情況：

Base64 每 3 個 bytes（24 bits）→ 對應 4 個 Base64 字元（每個 6 bits）。
如果最後一組的資料不足 6 位（即有餘數），Base64 編碼會用 "=" 符號來填充，確保編碼後的長度是 4 的倍數。

#### 例子 1：

假設我們有一個簡單的原始字串 "Cat"（ASCII 值為 67、97 和 116）來進行 Base64 編碼：

1. 轉換為二進位

"C" 的 ASCII 是 67，轉為二進位為 01000011。

"a" 的 ASCII 是 97，轉為二進位為 01100001。

"t" 的 ASCII 是 116，轉為二進位為 01110100。

2. 合併成一個 24 位的二進位數據：

```
01000011 01100001 01110100
```

3. 合併後的二進位數據是：

```
010000110110000101110100
```

4. 分成 4 組，每組 6 位：

```
010000 110110 000101 110100
```

5. 轉換為 Base64 字符：

010000 -> 16 -> 'Q'
110110 -> 54 -> '2'
000101 -> 5 -> 'F'
110100 -> 52 -> '0'

因此，"Cat" 的 Base64 編碼是 Q2F0.

#### 例子 2： 如果字串長度 bytes 不是 3 的倍數，會用 "=" 填充

這次我們用 `MA` 來說明

1. 轉換為二進位

  "M" = 77 = 01001101
  "a" = 97 = 01100001

2. 合併成一個 16 位的二進位數據：

  ```
  01001101 01100001
  ```

3. 補 8 個 0 到 24 bits：

  ```
  01001101 01100001 00000000
  ```

4. 分成 4 組，每組 6 位：

  ```
  010011 010110 000100 000000
  ```

5. 對應 Base64 字元（查表）：

  19 = T
  22 = W
  4 = E
  0 = A

6. 由於原始資料只有 2 bytes，我們知道最後一組是不完整的，所以：

  用兩個 Base64 字元來補充不足 → 最後 1 個字元是 padding `=`
  結果是：`TWE=`

**可以直接用下列小工具試試看喔！**

<Base64Demo />

---

參考資料：
[Wiki Unicode 區段](https://zh.wikipedia.org/zh-tw/Unicode%E5%8D%80%E6%AE%B5)
