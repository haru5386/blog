---
title: JavaScript 記憶體運作原理與垃圾回收：你真的懂 JS 怎麼釋放記憶體嗎？
date: 2025-04-09
category: basics
abstract: JavaScript 真的幫你全自動管理記憶體嗎？了解 stack、heap、垃圾回收機制與記憶體洩漏的常見陷阱，讓你寫出更穩定的程式。
tags: [memory, garbage-collection, javascript, performance, heap-stack]
---

### 記憶體與儲存結構：JavaScript 是怎麼存資料的？

在程式運作的過程中，記憶體是我們暫時放資料的地方，像你在料理時把食材放在料理台上，資料就這樣先擺著、用著，一直到你不再需要它。

在 JavaScript 裡，這些記憶體大致上分成兩個區塊：**棧（Stack） 和 堆（Heap）**。

##### 棧（Stack）：

- 儲存**基本資料**類型：數字、布林值、undefined、null 等
- 大小固定且有限
- 儲存函數呼叫和局部變數
- 一旦函式執行完畢，裡面的資料就會從棧中自動移除。
- 訪問速度快，遵循後進先出（LIFO）原則，舉例來說：

```c
function calculate() {
  let x = 10;        // 加入堆疊
  let y = 20;        // 加入堆疊
  let result = x + y; // 加入堆疊
  return result;     // result 離開堆疊
                    // y 離開堆疊
                    // x 離開堆疊
}
```

_JavaScript 函數調用過程時的 Call Stack (調用堆疊)，也是遵循後進先出（LIFO）原則，但和此處的 Stack (記憶體中的堆疊) 有所不同。_

##### 堆（Heap）：

- 結構比較靈活，適合儲存大型或複雜資料結構，像是物件（object）、陣列（array）、函式（也是一種物件）。
- 資料會存在記憶體中的某個位置，然後變數只儲存那個位置的參照（Reference）。
- 動態分配空間，大小不固定
- 訪問速度相對較慢
- 需要垃圾回收機制管理

```c
let obj = { name: 'Alice' }  // obj 的資料存在 Heap，Stack 中只記住參照位置
```

### 垃圾回收機制（Garbage Collection）

JavaScript 自動管理記憶體，主要使用兩種垃圾回收演算法：

#### 1. 標記-清除（Mark and Sweep）：

JavaScript 採用**自動垃圾回收機制**，最常見的是**標記清除法**，它是一種更複雜但也更有效的垃圾回收方式，不依賴簡單的引用計數（等等會介紹），因此能夠解決循環引用問題。這個算法分為兩個主要階段：

  1. **標記階段（Mark Phase）**
  垃圾回收器首先定義一些根節點（roots）：

    - 全域物件（如瀏覽器中的 window 或 Node.js 中的 global）  
    - 目前執行的函數的局部變數和參數  
    - 正在執行的閉包中的變數  

      然後，回收器遞迴地追蹤從這些根出發可以訪問到的所有物件，並標記它們為「在使用中」。

  2. **清除階段（Sweep Phase）**
  標記完成後，垃圾回收器遍歷整個堆記憶體：

  - 如果物件被標記為「在使用中」，則保留
  - 如果物件未被標記，則認為它是「沒在使用」的垃圾，可以被回收

  我們實際舉個例子來說：

  ```c
  let objectA = {};
  let objectB = {};

  objectA.refToB = objectB;
  objectB.refToA = objectA;

  // 斷開外部引用
  objectA = null;
  objectB = null;
  ``` 

  標記-清除算法處理這個情況的方式：

  **標記階段**：

  1. 從根（例如全域變數）開始
  2. 當 objectA 和 objectB 被設為 null 後，從根無法到達這兩個物件
  3. 即使它們互相引用，但因為無法從根訪問到，所以都不會被標記

  **清除階段**：

  4. 未被標記的 objectA 和 objectB 被識別為垃圾
  5. 這兩個物件都被回收，即使它們互相引用

  這就是標記-清除算法的優勢： **它不關心物件之間的引用關係，只關心物件是否可以從根訪問到。** 如果一組物件形成了循環引用，但無法從根到達，那麼整個循環都會被回收。

#### 2. 引用計數（Reference Counting）：

每個物件有一個「計數器」，記錄它被引用的次數。

當計數器為 0（沒人參考），該物件就可以被清除。

##### 缺點：容易出現循環引用（circular reference）導致記憶體洩漏

```c
const a = {}
const b = {}
a.b = b
b.a = a
// 雖然沒有用到，但彼此參照，計數永遠不為 0
```

##### 解決方案：現代引擎不單純依賴這種方式，而是結合「標記-清除」處理循環引用。

### V8 引擎的改進
現代 JavaScript 引擎如 V8（Chrome 和 Node.js 使用的引擎）進一步改進了標記-清除算法：

#### 分代回收（Generational Collection）：

將物件分為「新生代」和「老生代」
新建立的物件首先進入新生代
經過幾次垃圾回收後仍然存活的物件被移至老生代
新生代使用 Scavenge 算法快速回收
老生代使用更全面的標記-清除和標記-壓縮算法

#### 增量標記（Incremental Marking）：

將標記過程分解成小塊，與 JavaScript 執行交替進行
減少因垃圾回收造成的長時間暫停

#### 懶性清除（Lazy Sweeping）：

不立即清除所有未標記的物件
根據需要逐步清除，減少暫停時間

#### 並行處理（Concurrent Processing）：

在背景線程中進行部分垃圾回收工作
主線程可以繼續執行 JavaScript 代碼





<JsStorage />

<ClaudeJsStorage />
